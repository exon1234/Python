+ **http协议**

  http是超文本传输协议,是基于 TCP 传输协议的，发送数据之前需要先建立连接,它规定了浏览器和 Web 服务器通信数据的格式.

  URL由协议,域名,资源路径,查询字符串(?开头,$相连,#结束)组成

  查询字符串:?page=1&count=10

  + **http请求报文和响应报文**

    http请求最常见的是get和post方式,由**请求行+请求头+空行+请求体**组成,get方式没有请求体.

    响应报文由**响应行+响应头+空行+请求体**组成

    + 请求报文:

      由四部分组成,每部分要由\r\n隔开

      + GET请求(不包括请求体)
        + 请求行:GET请求方式 请求资源路径 HTTP协议版本
        + 请求头: 主机信息和一些参数,包括cookies,host等
        + 空行

      + POST请求
        + 组成比GET多一个请求体,用于传输数据

    + 响应报文:

      + 响应行:# HTTP协议版本 状态码 状态描述
      + 响应头
      + 空行
      + 响应体:响应的数据
      + 200:请求成功;307:重定向;400:错误的请求,地址或者参数有误;404:请求资源不存在;500:服务器内部源码出问题.

  + **状态码**
    + 1** 信息。服务器收到请求，需要请求者继续执行操作
    + 2** 成功。操作被成功接收并处理
    + 3** 重定向。需要进一步操作完成请求
    + 4** 客户端错误。请求有语法错误或者无法完成请求
    + 5** 服务器错误。服务器在处理请求的过程中发生错误

+ **浏览器访问web服务器过程**

  浏览器——DNS查询——TCP握手——HTTP请求——反向代理Nginx——uwsgi——web app响应 ——浏览器

## TCP/UDP的区别

- 面向连接、可靠的、基于字节流
- 无连接、不可靠、面向报文

## 三次握手

![三次握手](https://raw.githubusercontent.com/ZhiyuSun/assets/master/pic/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg)

第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认。

第二次握手：服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。

第三次握手：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

## 四次挥手

![四次挥手](https://raw.githubusercontent.com/ZhiyuSun/assets/master/pic/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg)

第一次挥手：客户端发送一个 FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

第二次挥手：服务器端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的FIN报文。

第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。

第四次挥手：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

## 为什么握手三次，挥手四次

首先 TCP 的定位是全双工的、支持半关闭的、可靠的传输协议。三次握手是可以最低限度地确定双方的信息是双向可用的（全双工）。

假设是 A 向 B 发起请求。 第二次握手成功表明 A => B 没问题。 第三次握手成功表明 B => A 没问题。

同时服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。

而四次挥手，TCP 要支持半关闭连接。建立的连接是全双工的，A <=> B 双方都可以读写。支持半关闭意味着，TCP 支持 A 和 B 双方独立关闭通道。因此会有两次独立的关闭写通道的请求。一次关闭请求（FIN），对应一个 ACK。